#include <iostream>
#include "Signatures.cpp"
#include "Index.cpp"
#include "args.h"
#include "utils.h"
#include <seqan/seq_io.h>
#include <seqan/sequence.h>

//Standard namespace declaration
using namespace std;

void printUsage()
{
    std::cerr
        << "usage: predX <command> <args>\n\n"
        << "The commands supported by predX are:\n\n"
        << "  index              Index the reference sequences\n"
        << "  quant              Run quantification algorithm [fasttext model]\n"
        << std::endl;
}

void printPredictUsage()
{
    std::cerr
        << "usage: metaMLP quant <args>\n\n"
        << "The commands supported by metaMLP quant are:\n\n"
        << "  -model        Trained model - generated by predX index\n"
        << "  -input        FASTA file with short sequence reads\n"
        << "  -output       output file to write the processed reads\n"
        << "  -kmer         k-mer size [default 11 - same kmer used in predX index]\n"
        << "  -seed         seed size [default 11 - amino acids]\n"
        << "  -mink         minimum number of kmers that each read has to contain [default 3]\n"
        << "  -NoReduced    Enable it if index is built with the -NoReduced option\n"
        << "  -tries        how many times tries to find a random seed [default 1] increse it to find more hits\n"
        << "  -minSeqLen    minimum sequence length of the sequences. It has to be greater than -kmer [default 100]\n"
        << std::endl;
}

void printIndexUsage()
{
    std::cerr
        << "usage: predX index <args>\n\n"
        << "The commands supported by predX index are:\n\n"
        << "  -input        Protein reference database\n"
        << "  -output       Output index\n"
        << "  -kmer         k-mer size in aminoacids [default 11]\n"
        << "  -labp         Label index position in the FASTA header (default 4: >xx|xx|xx|label|xx)\n"
        << "  -NoReduced    Dissable the reduced alphabet and use all 20 Amino Acids\n"
        << "  -dim          word vector size (default 100)\n"
        << std::endl;
}

struct thread_data
{

    Signatures *signatures;
    std::string fi;
    // std::string report;
    int tid; // thread ID
    seqan::StringSet<seqan::CharString> ids;
    seqan::StringSet<seqan::Dna5String> seqs;
    std::vector<std::string> readLabels;
    std::string buffer;
    std::unordered_map<std::string, std::tuple<std::string, float>> FuncPred;
};

void thread_process(void *args)
{
    struct thread_data *params;
    params = (struct thread_data *)args;

    (*params->signatures).predict(params->seqs, params->ids, params->readLabels, params->buffer, params->FuncPred);
}

void compute_absolute_abundance()
{
}

void quant(int argc, char **argv)
{

    if (argc < 3)
    {
        printPredictUsage();
        exit(0);
    }

    std::shared_ptr<fasttext::Args> a = std::make_shared<fasttext::Args>();
    a->parseArgs(argc, argv);

    // std::cout << a->mink << std::endl;

    std::string report_file = a->output;

    int NUM_THREADS = a->thread;

    std::thread threads[NUM_THREADS];
    struct thread_data td[NUM_THREADS];

    // ************************************** //
    // how to use: ./map /path/to/fasta/file.fa /path/to/signatures.txt /path/to/fastx/model
    // int kmer_size = stoi(kmer);
    // Load the signatures in json format kmer-size
    Signatures signatures(a);

    // Load Fasta File
    std::ifstream input(a->input);
    seqan::SeqFileIn seqFileIn(seqan::toCString(a->input));
    seqan::StringSet<seqan::CharString> ids;
    seqan::StringSet<seqan::Dna5String> seqs;

    // Open file and create Record Reader
    typedef seqan::Iterator<seqan::StringSet<seqan::Dna5String>>::Type NIter;
    seqan::CharString id;
    seqan::Dna5String seq;

    int ith = 0;
    int iseq = 0;
    int entries = 0;

    // ********************************************************************************************************
    // MAP SECTION
    // ********************************************************************************************************

    // read chunks of 10 reads at the time
    int chunks = a->minReadChunkSize;
    tsl::hopscotch_map<std::string, int> absolute_abundance;
    std::vector<std::string> label_sequence;
    int arglike = 0;

    std::ofstream fo(report_file);
    std::ofstream fabn(report_file + ".abn");

    std::cout << "Processing Input File" << std::endl;

    while (!atEnd(seqFileIn))
    {

        for (int thread_number = 0; thread_number < NUM_THREADS; thread_number++)
        {
            seqan::readRecords(ids, seqs, seqFileIn, chunks);
            entries += length(ids);
            // move data to thread and clear
            seqan::move(td[thread_number].seqs, seqs);
            seqan::move(td[thread_number].ids, ids);
            td[thread_number].signatures = &signatures;
            td[thread_number].tid = thread_number;

            seqan::clear(seqs);
            seqan::clear(ids);

            // start a the new thread
            threads[thread_number] = std::thread(thread_process, &td[thread_number]);
        }

        for (int thread_number = 0; thread_number < NUM_THREADS; thread_number++)
        {
            threads[thread_number].join();
        }

        // display # processed reads
        std::cout << " processed reads " << entries << "\r" << std::flush;
    }

    // ********************************************************************************************************
    // REDUCE SECTION
    // ********************************************************************************************************

    for (int i = 0; i < NUM_THREADS; i++)
    {
        for (const auto &arglabel : td[i].FuncPred)
        {
            // report individual classification
            label_sequence = fasttext::utils::splitString(std::get<0>(arglabel.second), '\t');
            fo << arglabel.first << "\t" << label_sequence[0] << "\t" << std::get<1>(arglabel.second) << "\n";

            // if a minimum probability of 0.5 report the sequence
            if (std::get<1>(arglabel.second) > 0.5)
            {
                absolute_abundance[label_sequence[0]] += 1;
            }

            arglike++;
        }
    }

    // printout results:
    std::stringstream ARGc;
    std::string HMP;
    for (const auto &item : absolute_abundance)
    {
        ARGc << item.first;
        HMP = ARGc.str();
        fabn << HMP.replace(HMP.length() - 2, HMP.length(), "").replace(0, 9, "") << "\t" << std::to_string(item.second) << std::endl;
        ARGc.str(std::string());
    }

    fabn.close();
    fo.close();

    std::cout << entries << " processed sequences " << std::endl;
    std::cout << arglike << " Annotated sequences " << std::endl;

    exit(0);
}

void index(int argc, char **argv)
{
    if (argc < 3)
    {
        printIndexUsage();
        exit(0);
    }

    std::shared_ptr<fasttext::Args> a = std::make_shared<fasttext::Args>();
    a->parseArgs(argc, argv);
    Index index;
    index.indexing(a->input, a->output, a->kmer, a->labp - 1, a->reduced);

    // training model
    std::cout << "Indexing reference database ..." << std::endl;
    fasttext::FastText fastText;

    a->model = fasttext::model_name::sup;
    a->loss = fasttext::loss_name::hs;
    a->input = a->output + ".tr";
    // a->epoch = 100;
    // a->lr = 1;
    // a->minCount = 1;
    // a->tries = 5;
    // a->dim = 100;
    // a->wordNgrams = 2;
    fastText.train(a);

    std::cout << "Cleaning temporal files ..." << std::endl;
    // remove(a->input.c_str());

    exit(0);
}

//Main Function
int main(int argc, char **argv)
{
    if (argc < 2)
    {
        printUsage();
        exit(0);
    }

    std::string command(argv[1]);
    if (command == "index")
    {
        index(argc, argv);
    }
    else if (command == "quant")
    {
        quant(argc, argv);
    }
    else
    {
        printUsage();
        exit(0);
    }

    return 0;
}
