#include <iostream>
#include "Signatures.cpp"
#include "Index.cpp"
#include "args.h"
#include "hdf5/H5Cpp.h"

//Standard namespace declaration
using namespace std;

void printUsage() {
  std::cerr
    << "usage: predX <command> <args>\n\n"
    << "The commands supported by predX are:\n\n"
    << "  index              Index the reference sequences\n"
    << "  quant              Run quantification algorithm [fasttext model]\n"
    << std::endl;
}

void printPredictUsage() {
  std::cerr
    << "usage: predX quant <args>\n\n"
    << "The commands supported by predX quant are:\n\n"
    << "  -model        Trained model - generated by predX index\n"
    << "  -input        FASTA file with short sequence reads\n"
    << "  -output       output file to write the processed reads\n"
    << "  -proc         Number of threads to use [default 8]\n "
    << "  -kmer         k-mer size [default 11 - same kmer used in predX index]\n"
    << "  -seed         seed size [default 9 - amino acids]\n"
    << std::endl;
}

void printIndexUsage() {
  std::cerr
    << "usage: predX index <args>\n\n"
    << "The commands supported by predX index are:\n\n"
    << "  -input        Protein reference database\n"
    << "  -output       Output index\n"
    << "  -kmer         k-mer size in aminoacids [default 11]\n"
    << "  -labp         Label index position in the FASTA header (default 4: >xx|xx|xx|label|xx)\n"
    << std::endl;
}

struct thread_data{

    Signatures *signatures;
    std::string fi;
    // std::string report;
    int tid; // thread ID
    seqan::StringSet<seqan::CharString> ids;
    seqan::StringSet<seqan::Dna5String> seqs;
    std::vector<std::string> readLabels;
    std::string buffer;
    std::unordered_map < std::string, std::tuple < std::string, float > > FuncPred;

};


void thread_process(void *args){
    struct thread_data *params;
    params = (struct thread_data *) args;

    (*params->signatures).predict(params->seqs, params->ids, params->readLabels, params->buffer, params->FuncPred);

    seqan::clear(params->seqs);
    seqan::clear(params->ids);
    params->readLabels.clear();
    params->buffer.clear();


}

void quant(int argc, char **argv){

    if (argc < 3) {
        printPredictUsage();
        exit(0);
    }

    std::shared_ptr<fasttext::Args> a = std::make_shared<fasttext::Args>();
    a->parseArgs(argc, argv);

    std::string finput = a->input;
    std::string output = a->output;
    std::string db = a->db;
    std::string smodel = a->smodel;
    std::string kmer = a->kmer;
    std::string proc = a->proc;
    int seed_size = std::stoi(a->seed);

    // Thread stuff
    std::string report_file = output;
    int NUM_THREADS = std::stoi(proc);

    std::thread threads[NUM_THREADS];
    struct thread_data td[NUM_THREADS];

    // ************************************** //
    // how to use: ./map /path/to/fasta/file.fa /path/to/signatures.txt /path/to/fastx/model
    int kmer_size = stoi(kmer);
    // Load the signatures in json format kmer-size
    Signatures signatures(db, smodel, kmer_size, seed_size, true);
    
    // Load Fasta File
    std::ifstream input(finput);
    seqan::SeqFileIn seqFileIn(seqan::toCString(finput));
    seqan::StringSet<seqan::CharString> ids;
    seqan::StringSet<seqan::Dna5String>  seqs;

    int ith=0;
    int iseq=0;
    int entries=0;
    
    if(NUM_THREADS==1){
        std::vector<std::string> readLabels;
        std::string buffer;
        std::unordered_map < std::string, std::tuple < std::string, float > > FuncPred;
        
        seqan::readRecords(ids, seqs, seqFileIn);
        signatures.predict(seqs, ids, readLabels, buffer, FuncPred);

        std::ofstream fo(report_file);

        int arglike=0;
        for(const auto& arglabel: FuncPred){
            fo << arglabel.first << "\t" << std::get<0>(arglabel.second) << "\t" << std::get<1>(arglabel.second) << "\n";
            arglike++;
        }
        fo.close();

        std::cout << "[***********************] 100%\n";
        std::cout << ith+1 << " threads used from " << NUM_THREADS << std::endl;
        std::cout << length(ids) << " processed reads " << std::endl;
        std::cout << arglike << " ARG-like reads " << std::endl;

        exit(0);
    }

    // ********************************************************************************************************
    // MAP SECTION
    // ********************************************************************************************************

    typedef seqan::Iterator< seqan::StringSet<seqan::Dna5String > >::Type NIter;

    seqan::CharString id;
    seqan::Dna5String seq;

    // estimate the number of reads
    struct stat st;
    stat(finput.c_str(), &st);
    
    seqan::readRecord(id, seq, seqFileIn);
    int all_reads = int( st.st_size/( length(id)+length(seq) ) );
    int chunks = int(all_reads/NUM_THREADS);

    std::string progress = "*";
    // std::vector < std::unordered_map < std::string, std::tuple < std::string, float > > > Predictions(NUM_THREADS);

    while (!atEnd(seqFileIn)){
        
        entries++;
        seqan::readRecord(id, seq, seqFileIn);
        
        if(length(seq)<100) continue;
        
        seqan::appendValue(seqs, seq);
        seqan::appendValue(ids, id);

        if(ith==NUM_THREADS-1) continue;
        
        if(iseq==chunks){

            std::cout << "["<< progress <<"] "<< entries << " reads " << 100*(ith+1)/NUM_THREADS <<"%\r";
            std::cout.flush();
            progress+="**";

            seqan::move(td[ith].seqs, seqs);
            seqan::move(td[ith].ids, ids);
            td[ith].signatures = &signatures;
            // td[ith].report = report_file;
            td[ith].tid = ith;
            // td[ith].FuncPred = FuncPred;

            seqan::clear(seqs);
            seqan::clear(ids);

            threads[ith] = std::thread(thread_process, &td[ith]);

            iseq=0;
            ith++;

        }else{
            iseq++;
        }
    
    
    }

    // when the estimated # of reads is greater than the actual number of reads we need to add the last thread. 
    std::cout << "["<< progress <<"] "<< entries << " reads " << 100*(ith+1)/NUM_THREADS <<"%\r";
    seqan::move(td[ith].seqs, seqs);
    seqan::move(td[ith].ids, ids);
    td[ith].signatures = &signatures;
    // td[ith].report = report_file;
    td[ith].tid = ith;
    
    seqan::clear(seqs);
    seqan::clear(ids);

    threads[ith] = std::thread(thread_process, &td[ith]);


    for( int i=0; i <= ith; i++ ){
        threads[i].join();
    }

    // ********************************************************************************************************
    // REDUCE SECTION
    // ********************************************************************************************************

    // printout results:
    std::ofstream fo(report_file);
    int arglike=0;
    for (int i=0; i<=ith; i++){
        for(const auto& arglabel: td[i].FuncPred){
            fo << arglabel.first << "\t" << std::get<0>(arglabel.second) << "\t" << std::get<1>(arglabel.second) << "\n";
            arglike++;
        }
    }

    fo.close();

    std::cout << "[***********************] "<< entries <<" reads 100%\n";
    std::cout << ith+1 << " threads used from " << NUM_THREADS << std::endl;
    std::cout << entries << " processed reads " << std::endl;
    std::cout << arglike << " ARG-like reads " << std::endl;
    
    exit(0);
}

void index(int argc, char **argv){
    if (argc < 3) {
            printIndexUsage();
            exit(0);
        }
    
    std::shared_ptr<fasttext::Args> a = std::make_shared<fasttext::Args>();
    a->parseArgs(argc, argv);
    Index index;
    index.indexing(a->input, a->output, std::stoi(a->kmer), std::stoi(a->labp)-1, true);

    // training model
    std::cout << "Indexing reference database ..." << std::endl;
    fasttext::FastText fastText;

    a->model = fasttext::model_name::sup;
    a->loss = fasttext::loss_name::hs;
    a->input = a->output+".tr";
    a->epoch = 50;
    a->lr = 1;
    a->minCount = 0;
    a->dim = 10;
    a->wordNgrams = 1;
    fastText.train(a);

    std::cout << "Cleaning temporal files ..." <<std::endl;
    remove(a->input.c_str());

    exit(0);
}

//Main Function
int main(int argc, char **argv)
{ 
    if (argc < 2) {
        printUsage();
        exit(0);
    }

    std::string command(argv[1]);
    if (command == "index" ) {
        index(argc, argv);
    } else if (command == "quant") {        
        quant(argc, argv);
    } else {
        printUsage();
        exit(0);
    }
    
    return 0;

}

